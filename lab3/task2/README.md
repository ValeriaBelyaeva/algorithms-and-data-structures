## Анти-quick sort
 Длясортировкипоследовательности чисел широко используется быстрая сор
тировка- QuickSort.ДалееприведенапрограмманаязыкеPascalPython,которая
 сортирует массив a, используя этот алгоритм.
 def qsort (left, right):
 key = a [(left + right) // 2]
 i = left
 j = right
 while i <= j:
 while a[i] < key: # first while
 i += 1
 while a[j] > key : # second while
 j-= 1
 if i <= j :
 a[i], a[j] = a[j], a[i]
 i += 1
 j-= 1
 if left < j:
 qsort(left, j)
 if i < right:
 qsort(i, right)
 qsort(0, n- 1)
 Хотя QuickSort является очень быстрой сортировкой в среднем, существуют те
сты, на которых она работает очень долго. Оценивать время работы алгоритма
 будем числом сравнений с элементами массива (то есть, суммарным числом срав
нений в первом и втором while). Требуется написать программу, генерирующую
 тест, на котором быстрая сортировка сделает наибольшее число таких сравнений.
 Задача на acmp.
 • Форматвходногофайла(input.txt).Впервойстрокенаходитсяединствен
ное число n (1 ≤ n ≤ 106).
 • Форматвыходногофайла(output.txt).Вывестиперестановкучиселот1до
 n, накоторойбыстраясортировкавыполнитмаксимальноечислосравнений.
 Если таких перестановок несколько, вывести любую из них.
 • Ограничение по времени. 2 сек.
 • Ограничение по памяти. 256 мб.